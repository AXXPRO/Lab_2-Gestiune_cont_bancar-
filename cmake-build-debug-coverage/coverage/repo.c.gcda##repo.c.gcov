        -:    0:Source:C:/Users/Gabi/Desktop/Lab_2-Gestiune_cont_bancar-/Infrastructura/repo.c
        -:    0:Graph:C:\Users\Gabi\Desktop\Lab_2-Gestiune_cont_bancar-\cmake-build-debug-coverage\CMakeFiles\Lab_2_Gestiune_cont_bancar_.dir\Infrastructura\repo.c.gcno
        -:    0:Data:C:\Users\Gabi\Desktop\Lab_2-Gestiune_cont_bancar-\cmake-build-debug-coverage\CMakeFiles\Lab_2_Gestiune_cont_bancar_.dir\Infrastructura\repo.c.gcda
        -:    0:Runs:1
        -:    1:#include <stdlib.h>
        -:    2:#include "repo.h"
        -:    3:#include <string.h>
function creaza_lista called 16 returned 100% blocks executed 100%
       16:    4:lista* creaza_lista( tip_lista tip)
        -:    5:{
       16:    6:    lista* v = (lista*)malloc(sizeof(lista));
       16:    7:    v->lungime_actuala=0;
       16:    8:    v->capacitate_maxima=2;
       16:    9:    v->elemente = (void**)malloc(sizeof(void*)*v->capacitate_maxima);
       16:   10:    v->tip = tip;
       16:   11:    return v;
       16:   11-block  0
        -:   12:}
        -:   13:
function sterge_tranzactie called 5 returned 100% blocks executed 100%
        5:   14:int sterge_tranzactie(lista* l, int id)
        5:   15:{ int ok =0;
       13:   16:    for(int i=0; i<l->lungime_actuala; i++)
        5:   16-block  0
        8:   16-block  1
       13:   16-block  2
branch  0 taken 8
branch  1 taken 5 (fallthrough)
        -:   17:    {
        8:   18:        if(get_id(l->elemente[i]) == id)
        8:   18-block  0
call    0 returned 8
branch  1 taken 4 (fallthrough)
branch  2 taken 4
        -:   19:        {
        4:   20:                ok = 1;
        -:   21:
        -:   22:
        4:   23:                free(((Tranzactie*) (l->elemente[i]))->descriere);
        4:   24:            free(l->elemente[i]);
        -:   25:
        6:   26:            for(int j=i; j<l->lungime_actuala-1; j++)
        4:   26-block  0
        6:   26-block  1
branch  0 taken 2
branch  1 taken 4 (fallthrough)
        -:   27:            {
        2:   28:                l->elemente[j] = l->elemente[j+1];
        2:   28-block  0
        -:   29:            }
        -:   30:
        4:   31:            l->lungime_actuala--;
        4:   31-block  0
        -:   32:
        -:   33:
        -:   34:        }
        -:   35:    }
        5:   36:    return ok;
        5:   36-block  0
        -:   37:
        -:   38:}
function adaugare_tranzactie called 36 returned 100% blocks executed 100%
       36:   39:void adaugare_tranzactie(lista* l, Tranzactie* tranz)
        -:   40:{
       64:   41:for (int i =0; i<l->lungime_actuala; i++)
       36:   41-block  0
       28:   41-block  1
       64:   41-block  2
branch  0 taken 29
branch  1 taken 35 (fallthrough)
        -:   42:{
       29:   43:    if(get_id(tranz)==get_id(l->elemente[i]))
       29:   43-block  0
call    0 returned 29
call    1 returned 29
branch  2 taken 1 (fallthrough)
branch  3 taken 28
        1:   44:    return;
        1:   44-block  0
        -:   45:}
        -:   46:
       35:   47:if(l->lungime_actuala == l->capacitate_maxima)
       35:   47-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 29
        6:   48:resize(l);
        6:   48-block  0
call    0 returned 6
        -:   49:
       35:   50:    l->elemente[l->lungime_actuala] = tranz;
       35:   51:    l->lungime_actuala++;
       35:   51-block  0
        -:   52:
        -:   53:
        -:   54:}
function resize called 6 returned 100% blocks executed 100%
        6:   55:void resize(lista* l)
        -:   56:{
        6:   57:     int capacitate_noua = 2*l->capacitate_maxima;
        6:   58: void** elemente_noi=(void**)malloc(sizeof(void*)*capacitate_noua);
        -:   59://copiez din vectorul existent
        -:   60: int i;
       18:   61: for (i = 0; i < l->lungime_actuala; i++) {
        6:   61-block  0
       18:   61-block  1
branch  0 taken 12
branch  1 taken 6 (fallthrough)
       12:   62:elemente_noi[i] = l->elemente[i];
       12:   62-block  0
        -:   63: }
        -:   64: //dealocam memoria ocupata de vector
        6:   65: free(l->elemente);
        6:   66: l->elemente= elemente_noi;
        6:   67: l->capacitate_maxima = capacitate_noua;
        -:   68:
        6:   69:}
        -:   70:
function get_tranzactie called 10 returned 100% blocks executed 100%
       10:   71:Tranzactie* get_tranzactie(lista* l, int id)
        -:   72:{
       21:   73:    for(int i=0; i<l->lungime_actuala; i++)
       10:   73-block  0
       11:   73-block  1
       21:   73-block  2
branch  0 taken 16
branch  1 taken 5 (fallthrough)
        -:   74:    {
       16:   75:      if(get_id(l->elemente[i])==id)
       16:   75-block  0
call    0 returned 16
branch  1 taken 5 (fallthrough)
branch  2 taken 11
        5:   76:      return l->elemente[i];
        5:   76-block  0
        -:   77:    }
        5:   78:    return (Tranzactie*)NULL;
        5:   78-block  0
        -:   79:}
        -:   80:
function modificare_tranzactie called 2 returned 100% blocks executed 100%
        2:   81:void modificare_tranzactie(lista* l, Tranzactie* tranz_noua, int id)
        -:   82:{
        6:   83:    for(int i=0; i<l->lungime_actuala; i++)
        2:   83-block  0
        4:   83-block  1
        6:   83-block  2
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        -:   84:    {
        4:   85:        if(get_id(l->elemente[i]) == id)
        4:   85-block  0
call    0 returned 4
branch  1 taken 2 (fallthrough)
branch  2 taken 2
        2:   86:        {   set_suma(l->elemente[i],get_suma(tranz_noua));
        2:   86-block  0
call    0 returned 2
call    1 returned 2
        2:   87:            set_ziua(l->elemente[i],get_ziua(tranz_noua));
call    0 returned 2
call    1 returned 2
        2:   88:            set_tip(l->elemente[i],get_tip(tranz_noua));
call    0 returned 2
call    1 returned 2
        -:   89:
        2:   90:            free(((Tranzactie*) (l->elemente[i]))->descriere);
        2:   91:            set_descriere(l->elemente[i],get_descriere(tranz_noua));
call    0 returned 2
call    1 returned 2
        -:   92:        }
        -:   93:    }
        2:   94:free(tranz_noua);
        2:   95:}
        -:   96:
function numar_elemente called 30 returned 100% blocks executed 100%
       30:   97:int numar_elemente(lista* l)
        -:   98:{
       30:   99:    return l->lungime_actuala;
       30:   99-block  0
        -:  100:}
        -:  101:
function distruge_lista_tranzactii called 16 returned 100% blocks executed 100%
       16:  102:void distruge_lista_tranzactii(lista* l)
        -:  103:{
        -:  104:    int i;
       47:  105:for (i = 0; i < l->lungime_actuala; i++) 
       16:  105-block  0
       47:  105-block  1
branch  0 taken 31
branch  1 taken 16 (fallthrough)
        -:  106:{
       31:  107:    free(((Tranzactie*) (l->elemente[i]))->descriere);
       31:  108:free(l->elemente[i]);
       31:  108-block  0
        -:  109:}
        -:  110:
       16:  111:free(l->elemente);
       16:  112:free(l);
       16:  113:}
        -:  114:
        -:  115:
        -:  116:
function get_all_tranzactii called 8 returned 100% blocks executed 100%
        8:  117:lista* get_all_tranzactii(lista* l)
        -:  118:{
        -:  119:
        8:  120:    lista* lista_returnat = creaza_lista(tranzactii);
        8:  120-block  0
call    0 returned 8
        -:  121:   // Tranzactie ** vector_tranzactii = (Tranzactie**)malloc(sizeof(Tranzactie*)*l->lungime_actuala);
        -:  122:
        -:  123:    //Tranzactie* tranzactie_copie = (Tranzactie*) malloc(sizeof(Tranzactie));
        -:  124:    char* descriere_copie;
        -:  125:
        -:  126:    Tranzactie* tranz_noua;
        -:  127:
        -:  128:   // tranz_noua= creaza_tranzactie(get_id(l->elemente[i]),get_suma(l->elemente[i]),get_zi(l->elemente[i]), get_tip(l->elemente[i]),descriere_copie);
        -:  129:   // adaugare_tranzactie(lista_returnat,tranz_noua);
        -:  130:
       24:  131:    for(int i=0; i<l->lungime_actuala; i++)
       24:  131-block  0
branch  0 taken 16
branch  1 taken 8 (fallthrough)
       16:  132:    {descriere_copie = (char*)malloc(sizeof(char)*50);
       16:  133:        strcpy(descriere_copie, get_descriere(l->elemente[i]));
       16:  133-block  0
call    0 returned 16
        -:  134:
       16:  135:        tranz_noua= creaza_tranzactie(get_id(l->elemente[i]),get_suma(l->elemente[i]),get_ziua(l->elemente[i]), get_tip(l->elemente[i]),descriere_copie);
call    0 returned 16
call    1 returned 16
call    2 returned 16
call    3 returned 16
call    4 returned 16
       16:  136:        adaugare_tranzactie(lista_returnat,tranz_noua);
call    0 returned 16
        -:  137:
        -:  138:    }
        -:  139:
        8:  140:    return lista_returnat;
        8:  140-block  0
        -:  141:
        -:  142:}
